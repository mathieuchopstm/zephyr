#!/usr/bin/env python3
#
# Copyright 2025 STMicroelectronics
#
# SPDX-License-Identifier: Apache-2.0
"""

"""

import argparse
import os
import pickle
import sys
import re

# This is needed to re-use code from gen_defines
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "dts"))
from gen_defines import node_z_path_id, str2ident

# This is needed to load edt.pickle files.
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "dts", "python-devicetree", "src"))

CONFIGURE_CELLS_PROPERTY_NAME = "#clock-cells"
STATIC_INIT_PROPERTY_NAME = "zephyr,cms-static-init"

def top_level_comment(root_node_path: str):
    WARN_MESSAGE = "THIS FILE IS AUTO-GENERATED BY gen_cms_header.py - DO NOT EDIT!"
    PATH_CAPTION = "Clock tree root:"

    line_length = len(WARN_MESSAGE) + 2
    stars = '*' * line_length

    comment = [stars,
               f"{WARN_MESSAGE:^{line_length}}",
               stars,
               f"{PATH_CAPTION:^{line_length}}",
               f"{root_node_path:^{line_length}}",
               stars]
    return "/*" + "*\n *".join(comment) + "*/\n\n"

def compatible_comment(compat: str, node_paths: list[str]):
    comment = ["\n/*"]
    comment.append(f" Macros for compatible = {compat}")
    comment.append(f"")
    comment.append(f" Used by:")
    comment.extend(f"\t- {np}" for np in node_paths)
    comment.append(f"/\n")
    return "\n *".join(comment)

def parse_args() -> argparse.Namespace:
    # Returns parsed command-line arguments

    parser = argparse.ArgumentParser(allow_abbrev=False)
    parser.add_argument("--edt-pickle", required=True,
                        help="path to read pickled edtlib.EDT object from")
    parser.add_argument("--header-out", required=True,
                        help="path to write header to")
    parser.add_argument("--init-code-out", required=True,
                        help="path to write clock static init code to")
    parser.add_argument("--clock-tree-root", required=True,
                        help="path to clock tree root in Device Tree")
    parser.add_argument("--subsystem-owned-compatible",
                        action='append', default=[],
                        help="compatible of subsystem-owned nodes that should be ignored")

    return parser.parse_args()

def main():
    args = parse_args()

    with open(args.edt_pickle, "rb") as f:
        edt = pickle.load(f)

    clock_tree_root = edt.get_node(args.clock_tree_root)
    if clock_tree_root is None:
        print(f"Clock tree root node ({args.clock_tree_root}) does not exist!", file=sys.stderr)
        return -1

    def ct_path(node):
        return node.path.replace(clock_tree_root.path, "(root)")

    def flat_tree_from_node(node, include_self=True):
        tree = [node] if include_self else []
        if len(node.children) == 0:
            return tree

        for child in node.children.values():
            if any([subsys_compat == node_compat
                    for subsys_compat in args.subsystem_owned_compatible
                    for node_compat in child.compats]):
                continue

            tree.extend(flat_tree_from_node(child))
        return tree

    ### Process information from Device Tree ###

    # Enumerate clock tree nodes (= children of the clock tree root node)
    # and sort list by dependency ordinal (i.e., in initialization order)
    clock_nodes = flat_tree_from_node(clock_tree_root, include_self=False)
    clock_nodes = sorted(clock_nodes, key=lambda n: n.dep_ordinal)

    # Sort nodes by compatible and note down which nodes have opted in
    # for static initialization, along with their compatible if so
    nodes_by_compat = {}
    compats_to_alias = {}
    static_init_nodes = []
    static_init_compats = set()
    for node in clock_nodes:
        # skip node if not enabled
        if not node.status == "okay":
            continue

        # skip bindingless nodes
        if node.matching_compat is None:
            continue

        compat = node.compats[0]
        if not compat in nodes_by_compat:
            nodes_by_compat[compat] = []

        if compat != node.matching_compat:
            existing_alias = compats_to_alias.get(compat)
            if existing_alias is None:
                compats_to_alias[compat] = node.matching_compat
            elif existing_alias != node.matching_compat:
                print(f"{node.name}: cannot alias '{compat}' to '{node.matching_compat}'"
                      f" as it is already aliased to {existing_alias}")
        nodes_by_compat[compat].append(node)

        p = node.props.get(STATIC_INIT_PROPERTY_NAME)
        if p is not None and p.val == True:
            static_init_nodes.append(node)
            static_init_compats.add(node.compats[0])

    with open(args.header_out, "w") as fp:
        def write_cond_macro(name: str, args: str, value="", required=False):
            fp.write(f"#ifndef {name}\n")
            if required:
                # Always define the macro, even if this is a dummy definition.
                # Having the macro defined will reduce/eliminate noisy and
                # undecipherable errors in the build log, hopefully leaving
                # only the #error message itself visible after build halts
                fp.write(f"#error Required macro {name} is not defined!\n")
                fp.write(f" /* Add dummy definition to reduce noise in build log */\n")
            fp.write(f"#define {name}{args} {value}\n")
            fp.write(f"#endif\n")

        def write_define(name: str, value: str | int):
            if isinstance(value, str):
                # this is probably something that could be long
                # split the value to a dedicated line
                # split value to a new line if string form
                value = "\\" + "\n" + "\t" + value
            fp.write(f"#define Z_CLOCK_MANAGEMENT_{name} {value}\n")

        fp.write(top_level_comment(clock_tree_root.path))

        # Write general macros:
        #   - number of clock nodes
        #   - number of nodes that want static initialization
        write_define("NUM_CLOCKS", len(clock_nodes))
        write_define("NUM_STATIC_INIT_CLOCKS", len(static_init_nodes))

        # Write compatible aliases
        # Aliases must come beforehand to avoid "macro not defined"
        # errors in the following blocks. Note that this means an
        # aliased compatible will never trigger errors, but that's
        # fine as its underlying compatible will.
        for aliased, destination in compats_to_alias.items():
            fp.write(f"\n/* Automatic alias of '{aliased}' to '{destination}' */\n")
            src = f"Z_CLOCK_MANAGEMENT_{str2ident(aliased).upper()}"
            dst = f"Z_CLOCK_MANAGEMENT_{str2ident(destination).upper()}"

            def write_alias(macro):
                write_cond_macro(f"{src}_{macro}", "", value=f"{dst}_{macro}")

            write_alias("DATA_DEFINE")
            write_alias("DATA_GET")
            write_alias("PRE_INIT")
            write_alias("INIT_DATA_DEFINE")
            write_alias("INIT_DATA_GET")
            write_alias("POST_INIT")
        fp.write("\n")

        # Write per-compatible stuff:
        #   - assertions checking that required macros are defined
        #   - dummy macros to reduce boilerplate in device driver headers
        for compat, nodes in nodes_by_compat.items():
            prefix = f"Z_CLOCK_MANAGEMENT_{str2ident(compat).upper()}"

            fp.write(compatible_comment(compat, [ct_path(n) for n in nodes]))

            # Check if this compatible is configure()-able.
            # For this, we need to know the value of #clock-cells...
            # however, EDTLib hides this from us, so we'll have to
            # look at internal stuff :(
            #
            # Second solution: look at node._binding.specifier2cells
            # (but that's still internal...)
            INTERNAL__node = nodes[0]._node
            p = INTERNAL__node.props.get(CONFIGURE_CELLS_PROPERTY_NAME)
            if p is not None and p.to_num() > 0:
                # This node can be configure()'ed.
                m_args = "(node, prop, idx)"

                # Emit a dummy macro for DATA_DEFINE
                # (configuration in often encoded in the pointer itself)
                write_cond_macro(f"{prefix}_DATA_DEFINE", m_args)

                # Emit assertion that DATA_GET has been defined
                write_cond_macro(f"{prefix}_DATA_GET", m_args, value="NULL", required=True)
            else:
                fp.write("/* Devices with this compatible cannot be configure()'ed */\n")

            # Check if this compatible has any instance that requires static init
            if compat in static_init_compats:
                # Emit a dummy macro for PRE_INIT and POST_INIT
                # (pre/post-configuration is often not needed)
                # Also emit assertion that STATIC_INIT_CFG has been defined
                # (it is always required here as static init is opt-in!)
                write_cond_macro(f"{prefix}_PRE_INIT", "(node)")
                write_cond_macro(f"{prefix}_INIT_DATA_DEFINE", "(node)")
                write_cond_macro(f"{prefix}_INIT_DATA_GET", "(node)", value="NULL", required=True)
                write_cond_macro(f"{prefix}_POST_INIT", "(node)")
            else:
                fp.write("/* No statically initialized device with this compatible */\n")

    with open(args.init_code_out, "w") as fp:
        fp.write(top_level_comment(clock_tree_root.path))

        if len(static_init_nodes) == 0:
            fp.write("/* zero nodes have requested static initialization */\n")
        else:
            # Emit static initialization code
            """
                * With clock_management_on(), this should be instead:
                *
                * 	static const struct clk *clk_hw = CLOCK_DT_GET(node_id);
                * 	IF_ENABLED(Z_CLOCK_MANAGEMENT_ compat _NEEDS_INIT_CONFIGURE, (
                * 		static const void *init_data =
                * 			Z_CLOCK_MANAGEMENT_ compat _INIT_DATA_GET(node_id);
                * 		ret = clock_configure(clk_hw, init_data);
                * 		if (ret < 0) { break; }
                * 	));
                * 	ret = clock_enable(clk_hw);
                * 	if (ret < 0) { break; }
            """

            INIT_FUNCTION_TEMPLATE = """\
int z_cms_static_init(void)
{{
{function_body}
    return 0;
}}

/* TODO: which level and prio? */
SYS_INIT(z_cms_static_init, PRE_KERNEL_1, 1);
""".replace(4 * " ", "\t").rstrip()

            CLOCK_INIT_TEMPLATE = """\
    {{   /* {node_path} */
        Z_CLOCK_MANAGEMENT_{compat}_PRE_INIT({node_id});
        Z_CLOCK_MANAGEMENT_{compat}_INIT_DATA_DEFINE({node_id});
        static const void *init_data = (void *)(Z_CLOCK_MANAGEMENT_{compat}_INIT_DATA_GET({node_id}));
        static const struct clk *clk_hw = CLOCK_DT_GET({node_id});

        int ret = clock_configure(clk_hw, init_data);

        if (ret < 0) {{
    #ifdef CMS__LOG_STATIC_INIT_ERROR
            printk(
                "Failed to configure %s during static init: %d\\n",
                DT_NODE_PATH({node_id}), ret);
    #endif
            //k_panic();
            return ret;
        }}

        Z_CLOCK_MANAGEMENT_{compat}_POST_INIT({node_id});
    }}
""".replace(4 * " ", "\t").rstrip()

            init_fn_code = ""
            for node in static_init_nodes:
                init_fn_code += CLOCK_INIT_TEMPLATE.format(
                    compat=str2ident(node.compats[0]).upper(),
                    node_id=f"DT_{node_z_path_id(node)}",
                    node_path=ct_path(node)
                ) + "\n"
            fp.write(INIT_FUNCTION_TEMPLATE.format(function_body=init_fn_code))

    return 0

if __name__ == "__main__":
    sys.exit(main())
